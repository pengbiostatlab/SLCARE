[{"path":"http://www.metaknight.us/SLCARE/articles/SLCARE.html","id":"data-and-model-assumption","dir":"Articles","previous_headings":"","what":"Data and Model assumption","title":"SLCARE","text":"Let \\(T_{} ^{(j)}\\) denote time \\(j^{th}\\) recurrent event, \\(\\tilde{Z} _{}\\) denote \\(p \\times 1\\) vector time-independent covariates, \\(C_{}\\) censoring time. Counting process recurrent events: \\[ N_{} ^{*} (t) = \\sum _{j = 1} ^{\\infty} (T_{} ^{(j)} \\leq t), = 1,\\cdots ,n \\] Assume \\(N_{} ^{*} (t)\\) non-stationary Poisson process intensity function: \\[ \\lambda _{} (t) = \\sum _{k = 1} ^{K} (\\xi _{} = k) \\times \\lambda _{0} (t) \\times W_{} \\times \\eta _{0,k} \\times exp(\\tilde{Z} _{} ^{T} \\tilde{\\beta} _{0,k})\\tag{1} \\] : \\(K\\) : pre-determined number latent class \\(\\xi _{}\\): un-observable latent class membership \\(\\lambda _{0} (t)\\): unspecified, continuous, non-negative baseline intensity function shared among different latent class \\(W_{}\\): positive subject-specific latent variable independent \\((\\xi, \\tilde{Z}, C)\\), \\(W_{}\\) offers flexibility accommodate individual difference larger smaller value indicating less frequent occurence recurrent events. Unknown class-specific parameters: \\(\\eta _{0,k}\\) Captures class-k scale shift baseline intensity function \\(\\tilde{\\beta} _{0,k}\\) represents class-k corvariate effects intensity function ensure identifiability \\(\\lambda _{0} (t)\\) \\(\\eta _{0,k}\\) (1), assume \\(E(W_{} | \\tilde{Z}_{} , \\xi _{} = k) = 1\\) \\(k = 1, \\cdots, K\\) impose constraint: \\[ \\int _{0} ^{v^{*}} \\lambda _{0} (t) dt = 1 \\tag{2} \\] \\(v^{*}\\) predetermined constant practice, may chosen slightly smaller upper bound \\(C_{}\\) ’s support imply scale shift \\(\\lambda _0 (t)\\) constant \\(\\eta _{0,k}\\) \\(\\tilde{\\beta} _{0,k}\\) remaining address difficulty unobservable latent class membership, assume multinomial logistic regression model \\(\\xi _{}\\) : \\[ P(\\xi _{} = k | \\tilde{Z} _{}) = p_{k} (\\alpha _{0} , \\tilde{Z} _{}) = \\frac{exp(\\tilde{Z} _{} ^{T} \\alpha _{0,k})}{\\sum_{k = 1}^{K}exp(\\tilde{Z} _{} ^{T} \\alpha _{0,k}) } , k = 1, \\cdots, K \\tag{3} \\] : \\(\\alpha _0 = (\\alpha _{0,1} ^{K}, \\dots, \\alpha _{0,K}^{K})^{T}\\)","code":""},{"path":"http://www.metaknight.us/SLCARE/articles/SLCARE.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"SLCARE","text":"illustrate usage SLCARE SLCARE_simdat SLCARE package.","code":"library(SLCARE) data(\"SLCARE_simdat\", package = \"SLCARE\") head(SLCARE_simdat) #>       ID time event x1        x2 #> 1 UOM054   65     1  0 0.5555556 #> 2 UOM054  940     1  0 0.5555556 #> 3 UOM054 2420     1  0 0.5555556 #> 4 UOM054 2475     1  0 0.5555556 #> 5 UOM054 2650     1  0 0.5555556 #> 6 UOM054 3830     1  0 0.5555556"},{"path":"http://www.metaknight.us/SLCARE/articles/SLCARE.html","id":"fit-the-model-with-k-2-with-frailty-w-1-","dir":"Articles","previous_headings":"Examples","what":"Fit the model with K = 2 with frailty \\(W = 1\\).","title":"SLCARE","text":"Note default, initial values iteration based estimation procedure derived K- means multiplicative intensity model studies Wang et al. (2001) using reReg() function. See SLCARE::get_initial() details. SLCARE return list containing: can check point estimates \\(\\alpha\\) \\(\\beta\\) can check posterior prediction observed events subjects interest can check posterior probability latent class membership can check plot model checking  can check plot \\(\\hat{\\mu} _{0}(t)\\)  can check \\(\\hat{\\mu} _{0} (t)\\) specific time points. example, let \\(t = 100, 1000, 5000\\) can check plot estimated mean function  can check relative entropy fitted model can check initial values iteration based estimation procedure","code":"model1 <- SLCARE(dat = SLCARE_simdat, K=2) names(model1) #>  [1] \"alpha\"                   \"beta\"                    #>  [3] \"convergeloss\"            \"PosteriorPrediction\"     #>  [5] \"EstimatedTau\"            \"ModelChecking\"           #>  [7] \"est_mu0\"                 \"Estimated_mu0t\"          #>  [9] \"Estimated_Mean_Function\" \"RelativeEntropy\"         #> [11] \"InitialAlpha\"            \"InitialBeta\" model1$alpha #>               x1        x2 #> class1 0.0000000  0.000000 #> class2 0.2204357 -3.736727 model1$beta #>        (Intercept)        x1         x2 #> class1    2.496767 -0.110277  0.1679575 #> class2    3.175178 -0.141808 -5.5362092 model1$PosteriorPrediction #>        ID PosteriorPrediction #> 1  UOM054          10.5227224 #> 2   EM015          11.5014781 #> 3    G078          11.4903563 #> 4  UOM048          11.9388759 #> 5    G050          11.1886724 #> 6    G058           3.8500141 #> 7   EM037           5.7373952 #> 8    G052           1.8489939 #> 9  UOM043           2.3018298 #> 10   G064          12.2549101 #> 11  EM036           1.7865768 #> 12 UOM003           7.2927102 #> 13  EM001           9.6461813 #> 14 UOM020           5.6180338 #> 15   G027           6.9236494 #> 16 UOM023          12.1637705 #> 17 UOM051           9.7369634 #> 18   G036          12.0859251 #> 19   G051          13.4306809 #> 20 UOM055          12.0733739 #> 21   G070           5.6079467 #> 22 UOM009           4.5591882 #> 23   G047          10.3564909 #> 24   G007          11.3667516 #> 25   G009          10.5893497 #> 26   G004           2.3224480 #> 27 UOM040          17.3172396 #> 28  EM013           3.1650867 #> 29   G066           1.7884215 #> 30   G021          11.1295757 #> 31   G061           8.0095335 #> 32 UOM031           0.8026416 #> 33  EM044           9.7559038 #> 34   G015           5.7280014 #> 35  EM018          12.8902131 #> 36 UOM050          13.1332526 #> 37   G005           8.0697634 #> 38   G003          10.4539334 #> 39   G018           5.0996630 #> 40   G057          11.7181383 #> 41   G072          11.6051441 #> 42 UOM005          13.1737497 #> 43   G019           4.0456816 #> 44 UOM025           9.4886388 #> 45   G065           2.1372540 #> 46  EM014          10.6922976 #> 47   G079           2.8322107 #> 48 UOM007           3.1004627 #> 49   G048           7.6133885 #> 50   G080          11.6309883 model1$EstimatedTau #>        ID      class1       class2 #> 1  UOM054 0.999999641 3.588689e-07 #> 2   EM015 0.999999270 7.296420e-07 #> 3    G078 0.998646435 1.353565e-03 #> 4  UOM048 1.000000000 3.410495e-13 #> 5    G050 0.998840723 1.159277e-03 #> 6    G058 0.437239412 5.627606e-01 #> 7   EM037 0.559913306 4.400867e-01 #> 8    G052 0.009863978 9.901360e-01 #> 9  UOM043 0.325872654 6.741273e-01 #> 10   G064 1.000000000 9.013150e-25 #> 11  EM036 0.001336693 9.986633e-01 #> 12 UOM003 0.188217597 8.117824e-01 #> 13  EM001 0.948642553 5.135745e-02 #> 14 UOM020 1.000000000 3.327574e-10 #> 15   G027 0.999976786 2.321358e-05 #> 16 UOM023 0.999999995 5.446992e-09 #> 17 UOM051 0.776284012 2.237160e-01 #> 18   G036 0.714972850 2.850272e-01 #> 19   G051 1.000000000 4.054462e-14 #> 20 UOM055 0.910532662 8.946734e-02 #> 21   G070 0.681826745 3.181733e-01 #> 22 UOM009 0.547115965 4.528840e-01 #> 23   G047 0.359803746 6.401963e-01 #> 24   G007 0.983611339 1.638866e-02 #> 25   G009 0.554658656 4.453413e-01 #> 26   G004 0.055220951 9.447790e-01 #> 27 UOM040 0.319408186 6.805918e-01 #> 28  EM013 0.546855255 4.531447e-01 #> 29   G066 0.012265950 9.877341e-01 #> 30   G021 0.969492976 3.050702e-02 #> 31   G061 0.290533287 7.094667e-01 #> 32 UOM031 0.618818075 3.811819e-01 #> 33  EM044 0.999824606 1.753943e-04 #> 34   G015 0.999977573 2.242684e-05 #> 35  EM018 0.999976933 2.306671e-05 #> 36 UOM050 1.000000000 3.290086e-11 #> 37   G005 0.433093210 5.669068e-01 #> 38   G003 0.702729729 2.972703e-01 #> 39   G018 0.545514459 4.544855e-01 #> 40   G057 0.999999892 1.077511e-07 #> 41   G072 0.612486202 3.875138e-01 #> 42 UOM005 1.000000000 5.818215e-13 #> 43   G019 0.447460375 5.525396e-01 #> 44 UOM025 0.999751903 2.480969e-04 #> 45   G065 0.309831911 6.901681e-01 #> 46  EM014 0.997311331 2.688669e-03 #> 47   G079 0.748248625 2.517514e-01 #> 48 UOM007 0.534013300 4.659867e-01 #> 49   G048 0.221051811 7.789482e-01 #> 50   G080 0.999999626 3.742849e-07 model1$ModelChecking model1$Estimated_mu0t #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' model1$est_mu0(c(100, 1000, 5000)) #> [1] 0.06086907 0.17089670 0.70936436 model1$Estimated_Mean_Function #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x' model1$RelativeEntropy #> [1] 0.5468913 model1$InitialAlpha #>                x1        x2 #> class1  0.0000000  0.000000 #> class2 -0.4984874 -2.447667 model1$InitialBeta #>        intercept         x1          x2 #> class1  2.563970 -0.2441563  0.06202144 #> class2  2.125367  0.0107472 -1.09947581"},{"path":"http://www.metaknight.us/SLCARE/articles/SLCARE.html","id":"fit-the-model-with-k-2-with-frailty-w-1-and-apply-self-defined-initial-values-in-estimation-procedure-","dir":"Articles","previous_headings":"Examples","what":"Fit the model with K = 2 with frailty \\(W = 1\\) and apply self-defined initial values in estimation procedure.","title":"SLCARE","text":"","code":"alpha <- matrix(c(0, 0, 0.5, -2, 2, -4), nrow = 3, ncol = 2, byrow = TRUE) beta <- matrix(c(2.5, -0.5, -0.3, 1.5, -0.2, -0.5, 2.5,  0.1, 0.2), nrow = 3 , ncol = 2+1 , byrow = TRUE) model2 <- SLCARE(alpha, beta, dat = SLCARE_simdat)"},{"path":"http://www.metaknight.us/SLCARE/articles/SLCARE.html","id":"fit-the-model-with-k-2-with-frailty-w-sim-gamma33-and-apply-self-defined-initial-values-in-estimation-procedure-","dir":"Articles","previous_headings":"Examples","what":"Fit the model with K = 2 with frailty \\(W \\sim gamma(3,3)\\) and apply self-defined initial values in estimation procedure.","title":"SLCARE","text":"may also calculate bootstrap standard errors using boot argument can check bootstrap standard errors","code":"model3 <- SLCARE(alpha, beta, dat = SLCARE_simdat, gamma = 3) # model4 <- SLCARE(alpha, beta, dat = SLCARE_simdat, boot = 100) # model4$alpha_bootse # model4$beta_bootse"},{"path":"http://www.metaknight.us/SLCARE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Qi Yu. Author, maintainer. Limin Peng. Author.","code":""},{"path":"http://www.metaknight.us/SLCARE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yu Q, Peng L (2023). SLCARE: Semiparametric Latent Class Analysis Recurrent Event. https://github.com/qyxxx/SLCARE, http://www.metaknight.us/SLCARE/.","code":"@Manual{,   title = {SLCARE: Semiparametric Latent Class Analysis for Recurrent Event},   author = {Qi Yu and Limin Peng},   year = {2023},   note = {https://github.com/qyxxx/SLCARE, http://www.metaknight.us/SLCARE/}, }"},{"path":[]},{"path":"http://www.metaknight.us/SLCARE/index.html","id":"semiparametric-latent-class-analysis-for-recurrent-events","dir":"","previous_headings":"","what":"Semiparametric Latent Class Analysis for Recurrent Events","title":"Semiparametric Latent Class Analysis for Recurrent Event","text":"SLCARE implements latent class analysis recurrent event data based semiparametric multiplicative modeling. can install SLCARE github :","code":"if (!require(\"devtools\", quietly = TRUE))     install.packages(\"devtools\")  devtools::install_github(\"qyxxx/SLCARE\")"},{"path":"http://www.metaknight.us/SLCARE/index.html","id":"online-documentation","dir":"","previous_headings":"Semiparametric Latent Class Analysis for Recurrent Events","what":"Online documentation","title":"Semiparametric Latent Class Analysis for Recurrent Event","text":"online document includes: Format input dataset Using SLCARE Function Reference Estimation Procedure","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/PreprocessData.html","id":null,"dir":"Reference","previous_headings":"","what":"data pre-processing — PreprocessData","title":"data pre-processing — PreprocessData","text":"pre-process data long wide formats fit functions R package","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/PreprocessData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"data pre-processing — PreprocessData","text":"","code":"PreprocessData(dat = dat)"},{"path":"http://www.metaknight.us/SLCARE/reference/PreprocessData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"data pre-processing — PreprocessData","text":"dat data frame containing data model","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/PreprocessData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"data pre-processing — PreprocessData","text":"list containing following components:","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE.html","id":null,"dir":"Reference","previous_headings":"","what":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","title":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","text":"Conduct Semiparametric Latent Class Analysis Recurrent Event.","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","text":"","code":"SLCARE(   alpha = NULL,   beta = NULL,   dat,   K = NULL,   gamma = 0,   max_epoches = 500,   conv_threshold = 0.01,   boot = NULL )"},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","text":"alpha initial values alpha estimation procedure. NULL numberic matirx. NULL means obtain initial value k-means. beta initial value beta estimation procedure. NULL numberic matirx. NULL means obtain initial value k-means. dat data frame containing data model K number latent classes gamma individual frailty. 0 represents frailty equals 1 k represents frailty follows gamma(k,k) max_epoches maximum iteration epoches estimation procedure conv_threshold converge threshold estimation procedure boot bootstrap sample size","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","text":"list containing following components: alpha Point estimates alpha beta Point estimates beta convergeloss Converge loss estimation procedure PosteriorPrediction Posterior prediction observed events subjects interest EstimatedTau Posterior probability latent class membership ModelChecking Plot model checking Estimated_mu0t Plot estimated mu0(t) est_mu0() function allows calculate mu0(t) specific time points Estimated_Mean_Function Plot estimated mean functions RelativeEntropy Relative entropy InitialAlpha Initial alpha estimation procedure InitialBeta Initial beta estimation procedure argument 'boot' non-NULL, SLCARE returns two additional components: alpha_bootse Bootstrap standard error alpha beta_bootse Bootstrap standard error beta","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semiparametric Latent Class Analysis for Recurrent Event — SLCARE","text":"","code":"data(SLCARE_simdat) # Example 1: number of latent classes k = 2, # By default, generate initial values in estimation procedure with K-means model1 <- SLCARE(dat = SLCARE_simdat, K=2) # contents of output names(model1) #>  [1] \"alpha\"                   \"beta\"                    #>  [3] \"convergeloss\"            \"PosteriorPrediction\"     #>  [5] \"EstimatedTau\"            \"ModelChecking\"           #>  [7] \"est_mu0\"                 \"Estimated_mu0t\"          #>  [9] \"Estimated_Mean_Function\" \"RelativeEntropy\"         #> [11] \"InitialAlpha\"            \"InitialBeta\"             # point estimates model1$alpha #>                x1       x2 #> class1  0.0000000 0.000000 #> class2 -0.2204357 3.736727 model1$beta #>        (Intercept)        x1         x2 #> class1    3.175178 -0.141808 -5.5362092 #> class2    2.496767 -0.110277  0.1679575 # converge loss in estimation procedure model1$convergeloss #> [1] 0.008254239 # Posterior prediction model1$PosteriorPrediction #>        ID PosteriorPrediction #> 1  UOM054          10.5227224 #> 2   EM015          11.5014781 #> 3    G078          11.4903563 #> 4  UOM048          11.9388759 #> 5    G050          11.1886724 #> 6    G058           3.8500141 #> 7   EM037           5.7373952 #> 8    G052           1.8489939 #> 9  UOM043           2.3018298 #> 10   G064          12.2549101 #> 11  EM036           1.7865768 #> 12 UOM003           7.2927102 #> 13  EM001           9.6461813 #> 14 UOM020           5.6180338 #> 15   G027           6.9236494 #> 16 UOM023          12.1637705 #> 17 UOM051           9.7369634 #> 18   G036          12.0859251 #> 19   G051          13.4306809 #> 20 UOM055          12.0733739 #> 21   G070           5.6079467 #> 22 UOM009           4.5591882 #> 23   G047          10.3564909 #> 24   G007          11.3667516 #> 25   G009          10.5893497 #> 26   G004           2.3224480 #> 27 UOM040          17.3172396 #> 28  EM013           3.1650867 #> 29   G066           1.7884215 #> 30   G021          11.1295757 #> 31   G061           8.0095335 #> 32 UOM031           0.8026416 #> 33  EM044           9.7559038 #> 34   G015           5.7280014 #> 35  EM018          12.8902131 #> 36 UOM050          13.1332526 #> 37   G005           8.0697634 #> 38   G003          10.4539334 #> 39   G018           5.0996630 #> 40   G057          11.7181383 #> 41   G072          11.6051441 #> 42 UOM005          13.1737497 #> 43   G019           4.0456816 #> 44 UOM025           9.4886388 #> 45   G065           2.1372540 #> 46  EM014          10.6922976 #> 47   G079           2.8322107 #> 48 UOM007           3.1004627 #> 49   G048           7.6133885 #> 50   G080          11.6309883 # Posterior probability of latent class membership model1$EstimatedTau #>        ID       class1      class2 #> 1  UOM054 3.588689e-07 0.999999641 #> 2   EM015 7.296420e-07 0.999999270 #> 3    G078 1.353565e-03 0.998646435 #> 4  UOM048 3.410495e-13 1.000000000 #> 5    G050 1.159277e-03 0.998840723 #> 6    G058 5.627606e-01 0.437239412 #> 7   EM037 4.400867e-01 0.559913306 #> 8    G052 9.901360e-01 0.009863978 #> 9  UOM043 6.741273e-01 0.325872654 #> 10   G064 9.013150e-25 1.000000000 #> 11  EM036 9.986633e-01 0.001336693 #> 12 UOM003 8.117824e-01 0.188217597 #> 13  EM001 5.135745e-02 0.948642553 #> 14 UOM020 3.327574e-10 1.000000000 #> 15   G027 2.321358e-05 0.999976786 #> 16 UOM023 5.446992e-09 0.999999995 #> 17 UOM051 2.237160e-01 0.776284012 #> 18   G036 2.850272e-01 0.714972850 #> 19   G051 4.054462e-14 1.000000000 #> 20 UOM055 8.946734e-02 0.910532662 #> 21   G070 3.181733e-01 0.681826745 #> 22 UOM009 4.528840e-01 0.547115965 #> 23   G047 6.401963e-01 0.359803746 #> 24   G007 1.638866e-02 0.983611339 #> 25   G009 4.453413e-01 0.554658656 #> 26   G004 9.447790e-01 0.055220951 #> 27 UOM040 6.805918e-01 0.319408186 #> 28  EM013 4.531447e-01 0.546855255 #> 29   G066 9.877341e-01 0.012265950 #> 30   G021 3.050702e-02 0.969492976 #> 31   G061 7.094667e-01 0.290533287 #> 32 UOM031 3.811819e-01 0.618818075 #> 33  EM044 1.753943e-04 0.999824606 #> 34   G015 2.242684e-05 0.999977573 #> 35  EM018 2.306671e-05 0.999976933 #> 36 UOM050 3.290086e-11 1.000000000 #> 37   G005 5.669068e-01 0.433093210 #> 38   G003 2.972703e-01 0.702729729 #> 39   G018 4.544855e-01 0.545514459 #> 40   G057 1.077511e-07 0.999999892 #> 41   G072 3.875138e-01 0.612486202 #> 42 UOM005 5.818215e-13 1.000000000 #> 43   G019 5.525396e-01 0.447460375 #> 44 UOM025 2.480969e-04 0.999751903 #> 45   G065 6.901681e-01 0.309831911 #> 46  EM014 2.688669e-03 0.997311331 #> 47   G079 2.517514e-01 0.748248625 #> 48 UOM007 4.659867e-01 0.534013300 #> 49   G048 7.789482e-01 0.221051811 #> 50   G080 3.742849e-07 0.999999626 # model checking plot model1$ModelChecking  # Plot of estimated \\eqn(\\mu_0 (t)) for all observed time model1$Estimated_mu0t #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  # Estimated \\eqn(\\mu_0 (t)) # You may input multiple time points of interest model1$est_mu0(c(100, 1000, 5000)) #> [1] 0.06086907 0.17089670 0.70936436 # Plot of estimated mean function model1$Estimated_Mean_Function #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'  # Relative entropy model1$RelativeEntropy #> [1] 0.5468913 # Initial values for estimation procedure model1$InitialAlpha #>               x1       x2 #> class1 0.0000000 0.000000 #> class2 0.4984874 2.447667 model1$InitialBeta #>        intercept         x1          x2 #> class1  2.125367  0.0107472 -1.09947581 #> class2  2.563970 -0.2441563  0.06202144 # You can select initial value in estimation procedure manually alpha <- matrix(c(0, 0, 0.5, -2, 2, -4),                 nrow = 3, ncol = 2, byrow = TRUE) beta <- matrix(c(2.5, -0.5, -0.3, 1.5, -0.2, -0.5,                   2.5,  0.1, 0.2), nrow = 3 , ncol = 2+1 , byrow = TRUE) model2 <- SLCARE(alpha, beta, dat = SLCARE_simdat) # You can define individual frailty with gamma(p,p). # Below is an example with manually defined initial value and frailty gamma(3,3) model3 <- SLCARE(alpha, beta, dat = SLCARE_simdat, gamma = 3) # You can use bootstrap for bootstrap standard error. # Bootstrap sample size = 100 (time consuming procedure) # model4 <- SLCARE(alpha, beta, dat = SLCARE_simdat, boot = 100) # SLCARE() with \"boot\" argument will return to two additional contents: # \"alpha_bootse\", \"beta_bootse\" which are Bootsrap standard errors. # model4$alpha_bootse # model4$beta_bootse"},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE_simdat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated dataset — SLCARE_simdat","title":"Simulated dataset — SLCARE_simdat","text":"dataset simulated real world dataset id subjects identification time time recored including event longest followup time (censoring) event recurrent event indicator; 1 recurrent event recorded x1 dummy baseline covariate x2 continuous baseline covariate range 0 1","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE_simdat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated dataset — SLCARE_simdat","text":"","code":"data(SLCARE_simdat)"},{"path":"http://www.metaknight.us/SLCARE/reference/SLCARE_simdat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated dataset — SLCARE_simdat","text":"data frame 478 rows 5 variables.","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCA_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior prediction for model checking — SLCA_predict","title":"Posterior prediction for model checking — SLCA_predict","text":"Predict numbers recurrent events.","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCA_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior prediction for model checking — SLCA_predict","text":"","code":"SLCA_predict(alpha, beta, d, Z, mu_censor, gamma = 0)"},{"path":"http://www.metaknight.us/SLCARE/reference/SLCA_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior prediction for model checking — SLCA_predict","text":"alpha estimated alpha - multinomial regression coefficients latent class membership beta estimated beta - class d vector observed recurrent events subjects interest Z vector time-independent corvariates mu_censor vector estimated mu(C), C vector censoring time gamma individual frailty. 0 represents frailty equals 1 k reprsents frailty follows gamma(k,k)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/SLCA_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Posterior prediction for model checking — SLCA_predict","text":"list containing following components:","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/entropy.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate relative entropy — entropy","title":"Calculate relative entropy — entropy","text":"Calculate relative entropy selection individual frailty number latent classes","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/entropy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate relative entropy — entropy","text":"","code":"entropy(alpha, beta, d, Z, mu_censor, gamma = 0)"},{"path":"http://www.metaknight.us/SLCARE/reference/entropy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate relative entropy — entropy","text":"alpha regression coefficient multinomial logistic regression model beta class specific parameters recurrent model d vector observed recurrent events subjects interest Z vector time-independent corvariates mu_censor vector estimated mu(C), C vector censoring time gamma individual frailty. 0 represents frailty equals 1 k represents frailty follows gamma(k,k)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/entropy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate relative entropy — entropy","text":"numerical number measures relative entropy","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/get_initial.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain initial values for estimation procedure. — get_initial","title":"Obtain initial values for estimation procedure. — get_initial","text":"Obtain initial value alpha : 1. assign class membership subjects Kmeans, fit multinomial regression obtain alpha. Obtain initial value beta fitting multiplicative intensity model studies Wang et al. (2001) using reReg() function, stratified latent class membership assigned Kmeans.","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/get_initial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain initial values for estimation procedure. — get_initial","text":"","code":"get_initial(dat, K)"},{"path":"http://www.metaknight.us/SLCARE/reference/get_initial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain initial values for estimation procedure. — get_initial","text":"dat data frame containing data model K number latent classes","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/get_initial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain initial values for estimation procedure. — get_initial","text":"list containing following components:","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/mu_t.html","id":null,"dir":"Reference","previous_headings":"","what":"estimate mu(t) — mu_t","title":"estimate mu(t) — mu_t","text":"Estimate mu0 Nelson-Aalen type estimator assumed multiplicative intensity modeling recurrent events","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/mu_t.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"estimate mu(t) — mu_t","text":"","code":"mu_t(time_long, censor_long, t)"},{"path":"http://www.metaknight.us/SLCARE/reference/mu_t.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"estimate mu(t) — mu_t","text":"time_long long format time - events (excluding censoring time) censor_long long format censoring time (longest follow time) t time interest","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/mu_t.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"estimate mu(t) — mu_t","text":"estimated mu(t)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_D.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate P(D|xi, Z, C) — p_D","title":"Estimate P(D|xi, Z, C) — p_D","text":"Estimate P(Di = di | xi = k, Zi, Ci)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate P(D|xi, Z, C) — p_D","text":"","code":"p_D(d, beta, Z, mu_censor, gamma = 0)"},{"path":"http://www.metaknight.us/SLCARE/reference/p_D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate P(D|xi, Z, C) — p_D","text":"d vector observed recurrent events subjects interest beta class specific parameters recurrent model Z vector time-independent corvariates mu_censor vector estimated mu(C), C vector censoring time gamma individual frailty. 0 represents frailty equals 1 k represents frailty follows gamma(k,k)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate P(D|xi, Z, C) — p_D","text":"vector estimated P(Di_di | xi = k, Zi, Ci)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_xi.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate P(xi | Z, C) — p_xi","title":"Estimate P(xi | Z, C) — p_xi","text":"estimate P(xi = k | Zi, Ci)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_xi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate P(xi | Z, C) — p_xi","text":"","code":"p_xi(alpha, Z)"},{"path":"http://www.metaknight.us/SLCARE/reference/p_xi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate P(xi | Z, C) — p_xi","text":"alpha regression coefficient multinomial logistic regression model (xi) Z vector time-independent corvariates","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/p_xi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate P(xi | Z, C) — p_xi","text":"vector estimated P(xi = k | Zi, Ci)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimation algorithm - updating alpha — update_alpha","title":"Estimation algorithm - updating alpha — update_alpha","text":"Updating alpha estimation procedure. Updating alpha fitting weighted multinomial regression.","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimation algorithm - updating alpha — update_alpha","text":"","code":"update_alpha(alpha, beta, d, Z, mu_censor, gamma = 0)"},{"path":"http://www.metaknight.us/SLCARE/reference/update_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimation algorithm - updating alpha — update_alpha","text":"alpha matrix alpha updating - regression coefficient multinomial logistic regression model beta matrix beta updating - class specific parameters recurrent model d vector observed recurrent events subjects interest Z vector time-independent corvariates mu_censor vector estimated mu(C), C vector censoring time gamma individual frailty. 0 represents frailty equals 1 k represents frailty follows gamma(k,k)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimation algorithm - updating alpha — update_alpha","text":"matrix updated alpha - regression coefficient multinomial logistic regression model","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_beta.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimation algorithm - updating beta — update_beta","title":"Estimation algorithm - updating beta — update_beta","text":"Updating beta estimation procedure. Updating beta fitting \"pseudo\" weighted Poisson regression model","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_beta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimation algorithm - updating beta — update_beta","text":"","code":"update_beta(alpha, beta, d, Z, mu_censor, gamma = 0)"},{"path":"http://www.metaknight.us/SLCARE/reference/update_beta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimation algorithm - updating beta — update_beta","text":"alpha matrix alpha updating - regression coefficient multinomial logistic regression model beta matrix beta updating - class specific parameters recurrent model d vector observed recurrent events subjects interest Z vector time-independent corvariates mu_censor vector estimated mu(C), C vector censoring time gamma individual frailty. 0 represents frailty equals 1 k represents frailty follows gamma(k,k)","code":""},{"path":"http://www.metaknight.us/SLCARE/reference/update_beta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimation algorithm - updating beta — update_beta","text":"matrix updated beta - class specific parameters recurrent model","code":""}]
